【1】	反汇编中的名称变换：
		(1) AAA 类中定义的 int triple( ) 在反汇编代码中变为 <_ZN3AAA6tripleEv>
		(2) AAA 类中定义的 double work( int ) 在反汇编代码中变为 <_ZN3AAA4workEi>
	发现具有以下规律：
		(1) 3AAA 表示的是该方法所属的类信息，其中 3 代表类名的长度，AAA 代表类名
		(2) 6triple 和 4work 表示的是方法信息，其中 6 和 4 代表方法名的长度， triple 和 work 代表方法名
		(3) v 和 i 表示的是参数类型，其中 v 代表 void，i 代表 int
		(4) 至于开头的 _ZN 和 参数类型前的 E，大概是编译器钦定的？

【2】	使用动态链接时：	
		printf 变换成了 <printf@plt>
		其在反汇编中对应 plt( 过程链接表 ) 中的条目，无可执行代码

【3】	使用静态链接时：
		printf 变换成了 2647 个形形色色的带 printf 的函数 = =#
		且部分名字带 printf 的 section 都具有相当的规模，这大概就是 printf 的可执行代码

【4】	面向对象语言中类成员被编译的特征：
		(1) 数据成员被编译后，名字就消失了，应该是转换成了偏移量的形式
		(2) 函数成员的名字中加上了所属的类以及所带的参数类型信息
	静态链接产生的代码特征：
		(1) 在编译链接的时候，就会将需要执行的库的代码嵌入最终的可执行文件中，导致可执行文件十分庞大
		(2) 若使用到了一个库的函数，就需要将整个库的指令均嵌入可执行文件中，即便有很多函数用不上
		(2) 程序加载进内存执行的时候，内存中可能存在同一函数代码的多个拷贝
	动态链接产生的代码特征：
		(1) 在编译链接的时候，不会将需要执行的库的代码嵌入最终的可执行文件中，而是在程序执行时动态加载与卸载，导致可执行文件较小
		(2) 程序运行时只会加载所需要的函数，不会加载无关函数
		(3) 程序加载进内存执行的时候，内存中只会存在同一函数的唯一拷贝
